use tracing::debug;
use crate::config::DotdeployConfig;
use crate::modules::ConditionEvaluator;
use crate::store::Stores;
use crate::store::sqlite_files::StoreFile;
use crate::store::sqlite_modules::StoreModule;
use crate::utils::sudo::PrivilegeManager;
use crate::utils::{FileUtils, file_fs};
use color_eyre::eyre::{WrapErr, eyre};
use color_eyre::Result;
use handlebars::Handlebars;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use tokio::fs;
use toml::Value;

#[derive(Deserialize, Debug, Default)]
pub(crate) struct Generate {
    /// The path of the source file.
    pub(crate) target: String,
    /// The name of the source file.
    pub(crate) source: String,
    /// Shebang, e.g. "#!/bin/sh" for POSIX shell scripts.
    pub(crate) shebang: Option<String>,
    /// Comment start string, e.g. "#" for Bash scripts.
    pub(crate) comment_start: String,
    /// Optional content to prepend to the generated file.
    pub(crate) prepend: Option<String>,
    /// Optional content to append to the generated file.
    pub(crate) append: Option<String>,
    /// An optional conditional expression for file generation.
    #[serde(rename = "if")]
    pub(crate) condition: Option<String>,
}

impl ConditionEvaluator for Generate {
    fn eval_condition<T>(&self, context: &T, hb: &handlebars::Handlebars<'static>) -> Result<bool>
    where
        T: Serialize,
    {
        if let Some(ref condition) = self.condition {
            Self::eval_condition_helper(condition, context, hb)
        } else {
            // Just return true if there is no condition
            Ok(true)
        }
    }
}

impl Generate {
    pub(crate) async fn generate_file(
        &self,
        stores: &Stores,
        context: &HashMap<String, Value>,
        hb: &Handlebars<'static>,
        config: &DotdeployConfig,
        pm: Arc<PrivilegeManager>,
    ) -> Result<()> {
        // Retrieve all modules from the store
        let modules = stores.get_all_modules().await?;
        // FIXME 2025-03-20: There needs to be a better way

        // NOTE 2025-03-22: I guess either create a clone of the context map or use a mutex... but
        //   the mutex would block all other tasks while a clone allows concurrency.
        let mut context = context.clone();

        let mut content = String::new();
        // Add shebang if any
        if let Some(shebang) = &self.shebang {
            content.push_str(&format!("{}\n", shebang));
        }

        // Add preamble
        content.push_str(&format!(
            "{} {}\n{} {}\n",
            self.comment_start,
            "This file was auto-generated by dotdeploy.",
            self.comment_start,
            "It is NOT safe to edit this file. Changes will be overwritten!"
        ));

        // Handle prepend content if present
        if let Some(prepend) = &self.prepend {
            let mut rendered = hb
                .render_template(prepend, &context)
                .wrap_err_with(|| format!("Failed to render template {:?}", &prepend))?;
            if !rendered.ends_with("\n") {
                rendered.push('\n');
            }
            content.push_str(&rendered);
        }

        // Iterate through all modules and collect relevant content
        for module in modules.iter() {
            let location: PathBuf = [&module.location, &self.source].iter().collect();
            context.insert(
                "DOD_CURRENT_MODULE".to_string(),
                Value::String(module.name.clone()),
            );
            if location.exists() {
                // Read and render the content from each module
                let found_content = fs::read_to_string(&location).await?;
                let mut rendered = hb
                    .render_template(&found_content, &context)
                    .wrap_err_with(|| format!("Failed to render template {:?}", &found_content))?;

                content.push_str(&format!("\n{} {}\n", &self.comment_start, &module.name));
                if !rendered.ends_with("\n") {
                    rendered.push('\n');
                }
                content.push_str(&rendered);
            }
        }

        // Handle append content if present
        if let Some(append) = &self.append {
            let mut rendered = hb
                .render_template(append, &context)
                .wrap_err_with(|| format!("Failed to render template {:?}", &append))?;

            if !rendered.ends_with("\n") {
                rendered.push('\n');
            }
            content.push_str(&rendered);
        }

        // Write the generated content to the target file if not empty
        if !content.is_empty() {
            let file_utils = FileUtils::new(pm);
            let parent = Path::new(&self.target)
                .parent()
                .ok_or_else(|| eyre!("Could not get parent of {}", &self.target))?;
            // Backup file
            if !stores.check_backup_exists(&self.target).await? {
                debug!("Creating backup of {}", &self.target);
                if file_utils.check_file_exists(&self.target).await? {
                    stores.add_backup(&self.target).await?
                } else {
                    stores.add_dummy_backup(&self.target).await?
                }
            }

            file_utils.ensure_dir_exists(&parent).await?;
            fs::write(&self.target, content).await?;

            // Add a special module entry for generated content
            stores
                .add_module(&StoreModule {
                    name: "__dotdeploy_generated".to_string(),
                    location: file_fs::path_to_string(&config.modules_root)?,
                    user: Some(whoami::username()),
                    reason: "automatic".to_string(),
                    depends: None,
                    date: chrono::offset::Utc::now(),
                })
                .await?;

            // Add the generated file to the store
            stores
                .add_file(StoreFile {
                    module: "__dotdeploy_generated".to_string(),
                    source: None,
                    source_checksum: None,
                    target: file_fs::path_to_string(&self.target)?,
                    target_checksum: None,
                    operation: "generate".to_string(),
                    user: Some(whoami::username()),
                    date: chrono::offset::Utc::now(),
                })
                .await?;
        }

        Ok(())
    }
}
