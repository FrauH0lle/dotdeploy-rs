use crate::config::DotdeployConfig;
use crate::modules::{ConditionEvaluator, ConditionalComponent};
use crate::store::Store;
use crate::store::sqlite::SQLiteStore;
use crate::store::sqlite_files::StoreFile;
use crate::store::sqlite_modules::StoreModule;
use crate::utils::FileUtils;
use crate::utils::common::{bytes_to_os_str, os_str_to_bytes};
use crate::utils::sudo::PrivilegeManager;
use color_eyre::Result;
use color_eyre::eyre::{WrapErr, eyre};
use handlebars::Handlebars;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::ffi::OsStr;
use std::path::{Path, PathBuf};
use std::sync::{Arc, LazyLock};
use tokio::fs;
use toml::Value;
use tracing::debug;
use tracing::error;

#[derive(Deserialize, Debug, Default)]
#[serde(deny_unknown_fields)]
pub(crate) struct Generate {
    /// The path of the target file.
    pub(crate) target: PathBuf,
    /// The path of the source file.
    pub(crate) source: PathBuf,
    /// Shebang, e.g. "#!/bin/sh" for POSIX shell scripts.
    pub(crate) shebang: Option<String>,
    /// Comment start string, e.g. "#" for Bash scripts.
    pub(crate) comment_start: Option<String>,
    /// Optional content to prepend to the generated file.
    pub(crate) prepend: Option<String>,
    /// Optional content to append to the generated file.
    pub(crate) append: Option<String>,
    /// If automatically generated content like a warning at the beginning to the file or from which
    /// module the content is comming from should be added. This requires, that either
    /// `comment_start` is set or the file extension of `target` is recongnized.
    #[serde(default)]
    pub(crate) skip_auto_content: bool,
    /// An optional conditional expression for file generation.
    #[serde(rename = "if")]
    pub(crate) condition: Option<String>,
}

impl ConditionEvaluator for Generate {
    fn eval_condition<T>(&self, context: &T, hb: &handlebars::Handlebars<'static>) -> Result<bool>
    where
        T: Serialize,
    {
        if let Some(ref condition) = self.condition {
            Self::eval_condition_helper(condition, context, hb)
        } else {
            // Just return true if there is no condition
            Ok(true)
        }
    }
}

impl ConditionalComponent for Generate {
    fn log_error(&self, module: &str, location: &Path, err: impl std::fmt::Display) {
        error!(
            module,
            location = ?location,
            target = self.target.display().to_string(),
            "Generator condition evaluation failed: {}",
            err
        );
    }
}

static FILE_COMMENTS: LazyLock<HashMap<&'static OsStr, &'static str>> = LazyLock::new(|| {
    HashMap::from([
        (OsStr::new("rs"), "//"),
        (OsStr::new("sh"), "#"),
        (OsStr::new("bash"), "#"),
        (OsStr::new("zsh"), "#"),
        (OsStr::new("py"), "#"),
        (OsStr::new("r"), "#"),
        (OsStr::new("js"), "//"),
        (OsStr::new("el"), ";;"),
        (OsStr::new("lisp"), ";;"),
        (OsStr::new("lua"), "--"),
    ])
});

// const FILE_COMMENTS: HashMap<OsString, String> =
//     HashMap::from([(OsString::from_str("rs"), "//".to_string())]);

impl Generate {
    pub(crate) async fn generate_file(
        &self,
        store: &SQLiteStore,
        context: &HashMap<String, Value>,
        hb: &Handlebars<'static>,
        config: &DotdeployConfig,
        pm: Arc<PrivilegeManager>,
    ) -> Result<()> {
        // Retrieve all modules from the store
        let modules = store.get_all_modules().await?;
        let mut context = context.clone();

        let mut content = String::new();
        // Add shebang if any
        if let Some(shebang) = &self.shebang {
            content.push_str(&format!("{}\n", shebang));
        }

        let comment_start = if let Some(comment_start) = &self.comment_start {
            comment_start.to_string()
        } else {
            if let Some(ext) = self.target.extension() {
                let ext = ext.to_ascii_lowercase();
                match FILE_COMMENTS.get(ext.as_os_str()) {
                    Some(c) => c.to_string(),
                    None => "#".to_string(),
                }
            } else {
                "#".to_string()
            }
        };

        if !self.skip_auto_content {
            // Add preamble
            content.push_str(&format!(
                "{} {}\n{} {}\n",
                comment_start,
                "This file was auto-generated by dotdeploy.",
                comment_start,
                "It is NOT safe to edit this file. Changes will be overwritten!"
            ));
        }

        // Handle prepend content if present
        if let Some(prepend) = &self.prepend {
            let mut rendered = hb
                .render_template(prepend, &context)
                .wrap_err_with(|| format!("Failed to render template {:?}", &prepend))?;
            if !rendered.ends_with("\n") {
                rendered.push('\n');
            }
            content.push_str(&rendered);
        }

        // Iterate through all modules and collect relevant content
        for module in modules.iter() {
            let mut location = PathBuf::from(bytes_to_os_str(&module.location_u8));
            location.push(&self.source);

            context.insert(
                "DOD_CURRENT_MODULE".to_string(),
                Value::String(module.name.clone()),
            );
            if location.exists() {
                // Read and render the content from each module
                let found_content = fs::read_to_string(&location).await?;
                let mut rendered = hb
                    .render_template(&found_content, &context)
                    .wrap_err_with(|| format!("Failed to render template {:?}", &found_content))?;

                if !self.skip_auto_content {
                    content.push_str(&format!("\n{} {}\n", &comment_start, &module.name));
                }
                if !rendered.ends_with("\n") {
                    rendered.push('\n');
                }
                content.push_str(&rendered);
            }
        }

        // Handle append content if present
        if let Some(append) = &self.append {
            let mut rendered = hb
                .render_template(append, &context)
                .wrap_err_with(|| format!("Failed to render template {:?}", &append))?;

            if !rendered.ends_with("\n") {
                rendered.push('\n');
            }
            content.push_str(&rendered);
        }

        // Write the generated content to the target file if not empty
        if !content.is_empty() {
            let file_utils = FileUtils::new(pm);
            let parent = Path::new(&self.target)
                .parent()
                .ok_or_else(|| eyre!("Could not get parent of {}", &self.target.display()))?;
            // Backup file
            if !store.check_backup_exists(&self.target).await? {
                debug!("Creating backup of {}", &self.target.display());
                if file_utils.check_path_exists(&self.target).await? {
                    store.add_backup(&self.target).await?
                } else {
                    store.add_dummy_backup(&self.target).await?
                }
            }

            file_utils.ensure_dir_exists(&parent).await?;
            fs::write(&self.target, content).await?;

            // Add a special module entry for generated content
            store
                .add_module(&StoreModule {
                    name: "__dotdeploy_generated".to_string(),
                    location: config.modules_root.to_string_lossy().to_string(),
                    location_u8: os_str_to_bytes(&config.modules_root),
                    user: Some(whoami::username()),
                    reason: "automatic".to_string(),
                    depends: None,
                    date: chrono::offset::Utc::now(),
                })
                .await?;

            // Add the generated file to the store
            store
                .add_file(StoreFile {
                    module: "__dotdeploy_generated".to_string(),
                    source: None,
                    source_u8: None,
                    source_checksum: None,
                    target: self.target.to_string_lossy().to_string(),
                    target_u8: os_str_to_bytes(&self.target),
                    target_checksum: None,
                    operation: "generate".to_string(),
                    user: Some(whoami::username()),
                    date: chrono::offset::Utc::now(),
                })
                .await?;
        }

        Ok(())
    }
}
